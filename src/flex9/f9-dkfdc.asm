*
** FLEX 9 DISK DRIVERS
** FOR SINGLE/DOUBLE SIDED 5" DRIVES ONLY.
** USING FD1771.
** SIDES MAY BE TREATED AS SEPERATE DISKS.
**
** BY J.E.KENT   1 JAN 1982
*
*
** F.D. CONTROLLER
*
DRVREG EQU   $E014
MOTOR  EQU   %10000000
SIDESL EQU   %01000000
DRIVSL EQU   %00000001
CMDREG EQU   $E018
TRKREG EQU   $E019
SECREG EQU   $E01A
DATREG EQU   $E01B
*
** FD1771 DISK CONTROLLER INSTRUCTIONS
*
** TYPE I INSTRUCTIONS:
*
IREST EQU $00 RESTORE (SEEK TRACK 0)
ISEEK EQU $10 SEEK TRACK
ISTEP EQU $20 STEP ONE TRACK (IN/OUT)
ISTIN EQU $40 STEP IN ONE TRACK
ISTOUT EQU $60 STEP OUT ONE TRACK
*
** BIT FIELDS FOR TYPE I INSTRUCTIONS
*
SMR6 EQU $00 6MSEC STEPPING RATE
SMR12 EQU $01 12 MSEC STEPPING RATE
SMR20 EQU $02 20 MSEC
SMR40 EQU $03 40 MSEC
*
BVERIF EQU $04 VERIFY BIT (1=ON)
BHDLD EQU $08 HEAD LOAD (1=LOAD HEAD AT BEGINING)
BUPDAT EQU $10 UPDATE TRACK REGISTER (1=TRUE)
*
** TYPE II INSTRUCTIONS
*
IREAD EQU $80 READ SECTOR
IWRITE EQU $A0 WRITE SECTOR
*
** BIT FIELD FOR TYPE II
*
BDAMFB EQU $00 $FB DATA ADDRESS MARK
BDAMFA EQU $01 $FA DATA ADDREES MARK
BDAMF9 EQU $02 $F9 DATA ADDRESS MARK
BDAMF8 EQU $03 $F8 DATA ADDRESS MARK
BEHLD EQU $04 ENABLE HLD & 10 MSEC DELAY (1=ACTIVE)
BBLEN EQU $08 BLOCK LENGTH (1=IBM FORMAT 128 - 1024 BYTES)
BMREC EQU $10 MULTIPLE RECORD (0=SINGLE, 1=MULTIPLE)
*
** TYPE III INSTRUCTIONS
*
IRDADD EQU $C4 READ ADDRESS
IRDTRK EQU $E4 READ TRACK
IWRTRK EQU $F4 WRITE TRACK
*
** BIT FIELD TYPE III (READ TRACK ONLY)
*
BSYNC EQU $01 SYNCRONIZE FLAG (0=SYNC TO AM)
*
** TYPE IV NSTRUCTION
*
IFINTR EQU $D0 FORCE INTERRUPT
*
** FORCED INTERRUPT BITS (TYPE IV INSTRUCTION)
*
FI0 EQU $01 NOT READY TO READY TRANSITION
FI1 EQU $02 READY TO NOT READY TRANSITION
FI2 EQU $04 INDEX PULSE
FI3 EQU $08 EVERY 10 MSEC
*
** DISK DRIVER PATCHES
*
       ORG   $DE00
*
** JUMP TABLE TO DISK DRIVERS
*
READ   JMP   READSC
WRITE  JMP   WRITSC
VERIFY JMP   VERIF1
RESTOR JMP   RESTR1
DRIVE  JMP   DRVSEL
DRVRDY JMP   CHKDRV
QUICK  JMP   CHKDRV
COLDDR JMP   INITDR
WARMDR JMP   WARMD1
SEEK   JMP   SEEK1
*
** CURRNT DRIVE NUMBER ($DE1E)
*
CURDRV FCB   $00
*
** HEAD POSITION TABLE ($DE1F)
*
TRKTBL FCB   $00       DRIVE 0
       FCB   $00       DRIVE 1
       FCB   $00       DRIVE 2
       FCB   $00       DRIVE 3
*
** ??? ($DE23)
*
       FCB 0
*
** DENSITY TABLE: ($DE24)
** HOLDS SECTORS/TRACK FOR DRIVE
** 5" SINGLE DENSITY => 10 SECTORS/TRACK
*
DNSTBL FCB 10,10,10,10 ALL MINIS
*
** DRIVE & DISK CHARACTERISTICS
*
* BITS 1,0 STEPPING RATES
* BIT  2   TRACKS/DISK (0=40 TRACK, 1=80 TRACK)
* BIT  3   TRACKS/DRIVE (0=40 TRACK, 1=80 TRACK)
*
BDVTPI EQU $08
BDKTPI EQU $04
DDCTBL EQU *
 FCB BDVTPI+BDKTPI+SMR6
 FCB BDVTPI+BDKTPI+SMR6
 FCB SMR40
 FCB SMR40
*
** DISK DRIVERS
*
* DRIVER INITIATION
*
INITDR LDX   #CURDRV
       LDB   #5
INITD2 CLR   ,X+
       DECB
       BNE   INITD2
WARMD1 RTS
*
* READ ONE SECTOR
*
READSC BSR   SEEK1
       LDA   #IREAD+BBLEN+BEHLD
READ2  ORCC  #$10
*      SEI             DISABLE INTERRUPTS
       STA   CMDREG
       LBSR  DLY47
       LDB   #$00
RDLOOP LDA   CMDREG
       BITA  #$02
       BNE   RDBYTE
       BITA  #$01
       BNE   RDLOOP
       TFR   A,B
       BRA   RDEXIT
*
RDBYTE LDA   DATREG
       STA   ,X+
       DECB  
       BNE   RDLOOP
       BSR   WAIT
RDEXIT BITB  #$1C
       ANDCC #$EF
*      CLI
       RTS   
*
** WAIT UNTIL CONTROLLER READY
*
WAIT   LDB   CMDREG
       BITB  #$01
       BNE   WAIT
       RTS   
*
** SEEK1 TRACK AND SECTOR
** ACCA = TRACK NUMBER
** ACCB = SECTOR NUMBER
*
SEEK1  STB   SECREG    SET SECTOR
       CMPB  #10       DOUBLE-SIDED ?
       BHI   SEEK2     DOUBLE SIDED, FLIP
       LDB   CURDRV    BACK SIDE OF DISK ?
       CMPB  #1        DRIVE 2-3 BACK SIDE
       BHI   SEEK3
       ANDB  #$FF-SIDESL SELECT SIDE 0
       BRA   SEEK4
*
SEEK2  LDB   CURDRV   SELECT SIDE 1
SEEK3  ANDB  #DRIVSL
       ORB   #SIDESL
SEEK4  STB   DRVREG
*
       CMPA  TRKREG    DIFFERENT TO LAST ?
       BEQ   FOUND
       PSHS A          SAVE TRACK NO. ON STACK
*
* IF 80 TRACK DRIVE, & 40 TRACK DISK, FIRST SEEK
* SHOULD NOT UPDATE TRACK REGISTER NOR VERIFY.
*
       SUBA TRKREG  CALC. DIFFERENCE
       TFR  A,B
       PSHS Y
*
** GET STEPPING RATE FROM TABLE
*
       LDY  #DDCTBL
       LDA  CURDRV
       ANDA #$01
       LDA  A,Y
       PULS Y
*
** CHECK DRIVE AND DISK TYPE
*
       BITA #BDVTPI DRIVE TRACK DENSITY = 48 TPI ?
       BEQ  SEEKVU  YES, SKIP
       BITA #BDKTPI DISK TRACK DENSITY = 96 TPI ?
       BNE  SEEKVU  YES, SKIP (DRIVE & DISK MATCH)
*
** HERE IF 40TRACK DISK IN 80 TRACK DRIVE
** USE STEP INSTRUCTIONS TO PREVENT UPDATE OF TRACK REG.
*
       ANDA #$03    LEAVE STEPPING RATE BITS
       TSTB
       BPL  STEPIN  
       NEGB
       ORA  #ISTOUT
       BRA  STEPLP
STEPIN ORA  #ISTIN
STEPLP PSHS B
       BSR  SEEK5
       PULS B
       DECB
       BNE  STEPLP
*
** SEEK TRACK WITH VERIFY & UPDATE
*
SEEKVU ANDA #$03    RETAIN STEPPING RATE
       ORA  #ISEEK+BHDLD ($18)
       PULS B          RESTORE DEST TRACK NO.
       STB   DATREG    YES, SEEK1 NEW TRACK
       LBSR  DLY47
SEEK5  STA   CMDREG
       LBSR  DLY47
       BSR   WAIT
       BITB  #$10      CHECK FOR SEEK1 ERROR
FOUND  JMP   DLY47
*
** WRITE SECTOR TO DISK
*
WRITSC BSR   SEEK1
       LDA   #IWRITE+BBLEN+BEHLD ($AC)
WRITE2 ORCC  #$10
*      SEI
       STA   CMDREG
       LBSR  DLY47
       LDB   #$00
WRLOOP LDA   CMDREG
       BITA  #$02
       BNE   WRBYTE
       BITA  #$01
       BNE   WRLOOP
       TFR   A,B
       BRA   WREXIT
*
WRBYTE LDA   ,X+
       STA   DATREG
       DECB  
       BNE   WRLOOP
       LBSR  WAIT
WREXIT BITB  #$5C
       ANDCC  #$EF
*      CLI
       RTS   
*
** VERIFY SECTOR WRITTEN
*
VERIF1 LDA   #IREAD+BBLEN+BEHLD ($8C)
VERIF2 ORCC  #$10
*      SEI
       STA   CMDREG
       LBSR  DLY47
       LBSR  WAIT
       ANDCC #$EF
*      CLI
       BITB  #$18
       RTS   
*
** SEEK TRACK ZERO
*
RESTR1 PSHS  X
       BSR   DRVSEL
       LDX  #DDCTBL
       LDA  CURDRV
       ANDA #1
       LDA  A,X
       ANDA #$03
       ORA  #IREST+BHDLD
       STA   CMDREG
       BSR   DLY47
       LBSR  WAIT
       BITB  #$D8      CHECK FOR ERROR
       PULS  X,PC
*
** SELECT DRIVE
** IX -> FCB
** ACCA =  NEW DRIVE NUMBER
*
*  SAVE OLD TRACK NUMBER IN TABLE
*  AND SET UP TRACK FOR NEW DRIVE
*
*
DRVSEL LDA   3,X
       CMPA  #3
       BLS   DRSEL1
       LDB   #$0F      SET ERROR VALUE
*       SEC
       ORCC  #$01
       RTS
*
* SAVE TRACK POSITION OF PREVIOUS DRIVE
*
DRSEL1 BSR   PNTDRV
       LDB   TRKREG
       STB   ,X
*
* SELECT NEW DRIVE
*
DRSEL3 STA   CURDRV    MAY BE 0 - 3
       CMPA  #1
       BLS   DRSEL4    ONE DIRECTORY ?
       ANDA  #DRIVSL   ROUND OFF
       ORA   #SIDESL   SELECT SIDE 1
DRSEL4 STA   DRVREG
*
* RESTORE LAST TRACK POSITION FOR THIS DRIVE
*
       BSR   PNTDRV
       LDA   ,X
       STA   TRKREG
       BSR   DLY47
       BRA   OK
*
** CHECK IF DRIVE READY
*
CHKDRV LDA   3,X
       CMPA  #3
       BLS   OK
       LDB   #$80
*       SEC
       ORCC  #$01
       RTS

OK     CLRB
*       CLC
       ANDCC #$FE
       RTS
*
* POINT TO TRACK TABLE ENTRY FOR THIS DRIVE
*
PNTDRV LDX   #TRKTBL
       LDB   CURDRV
       ANDB   #DRIVSL
       ABX
       RTS
*
** DELAY ROUTINE
*
DLY47  LBSR  DLY19
DLY19  LBSR  DLY5US
DLY5US RTS
       END

