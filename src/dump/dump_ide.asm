*
* Sector Dump Utility 
* for IDE Drives or Compact Flash
* for the 6809
* revised for 16 bit peripheral bus
* on XESS XSA-3S1000 / XST-3.0
*
* John Kent
* 1 Feb 2008
*
* SYS09BUG
*
MON_BASE  EQU $F800
MONV      EQU MON_BASE+0
NEXTCV    EQU MON_BASE+2
INCHV     EQU MON_BASE+4
INCHEV    EQU MON_BASE+6
INCHEKV   EQU MON_BASE+8
OUTCHV    EQU MON_BASE+10
PDATAV    EQU MON_BASE+12
PCRLFV    EQU MON_BASE+14
PSTRGV    EQU MON_BASE+16
*
* Register Equates
*
CF_BASE    EQU $E100
CF_DATA    EQU CF_BASE+0
CF_ERROR   EQU CF_BASE+2 ; read error
CF_FEATURE EQU CF_BASE+2 ; write feature
CF_SECCNT  EQU CF_BASE+4
CF_SECNUM  EQU CF_BASE+6
CF_CYLLO   EQU CF_BASE+8
CF_CYLHI   EQU CF_BASE+10
CF_HEAD    EQU CF_BASE+12
CF_STATUS  EQU CF_BASE+14 ; read status
CF_COMAND  EQU CF_BASE+14 ; write command
CF_AUX     EQU CF_BASE+30
*
* Command Equates
*
AUXRESET   EQU $06 ; CF_AUX Reset command
AUXRELEA   EQU $02
CMDREAD    EQU $20 ; Read Single sector
CMDWRITE   EQU $30 ; Write Single sector
HEADLBA    EQU $E0
*
* Status bit equates
*
BUSY       EQU $80
DRDY       EQU $40
DRQ        EQU $08
ERR        EQU $01
*
* Start of Program
*
         ORG $0100
START    LBRA START1
*
* DATA STORAGE
*
SECNUM   FCB $00,$00,$00
CPORT    FDB $E000
ECHO     FCB $FF
*
* SECTOR BUFFER
*
SECBUF   RMB 512
*
* PROGRAM STACK
*
         RMB 64
STACK    EQU *
*
* Initialization
*
START1 LDS #STACK
*
* Clear sector buffer
*
       LDX #SECBUF
       LDY #0
       LDB #0
ZEROLP STY ,X++
       DECB
       BNE ZEROLP
*
* INITIALIZE CF CARD FOR 8 BIT LBA MODE
*
       LDD #AUXRESET
       STD CF_AUX
       LDD #AUXRELEA
       STD CF_AUX
       JSR WAITRDY
       LDD #HEADLBA
       STD CF_HEAD
       JSR WAITRDY
*
* DISPLAY TITTLE BANNER
*
       LDX #TTLMSG
       JSR PDATA
*
* COMMAND LOOP
* R - READ
* W - WRITE
* N - NEXT
* P - PREV
* M - MODIFY
* Q - QUIT
*
CMDLP  LDX #CMDMSG
       JSR PDATA
       JSR ECHON
       CMPA #'R'
       BEQ READ
       CMPA #'N'
       BEQ NEXT
       CMPA #'P'
       BEQ PREV
       CMPA #'W'
       LBEQ WRITE
       CMPA #'M'
       BEQ MODIFY
       CMPA #'Q'
       BEQ QUIT
       CMPA #'r'
       BEQ READ
       CMPA #'n'
       BEQ NEXT
       CMPA #'p'
       BEQ PREV
       CMPA #'w'
       LBEQ WRITE
       CMPA #'m'
       BEQ MODIFY
       CMPA #'q'
       BEQ QUIT
       LDX #WOTMSG
       JSR PSTRNG
       BRA CMDLP
*
* QUIT
*
QUIT   JMP [MONV]
*
* MODIFY SECTOR
*
MODIFY JSR MEMCHG
       BRA CMDLP
*
* NEXT SECTOR (READ)
* INCREMENT SECTOR NUMBER
* WRAPS AROUND TO ZERO ON $FFFFFF
*
NEXT   LDX SECNUM+1
       LEAX 1,X
       STX SECNUM+1
       BNE READS 
       INC SECNUM
       BRA READS
*
* PREVIOUS SECTOR (READ)
* DECREMENT SECTOR NUMBER
* DON'T DECREMENT PAST $000000
*
PREV   LDX SECNUM+1
       BNE PREV1
       TST SECNUM
       BEQ READS
       DEC SECNUM
PREV1  LEAX -1,X
       STX SECNUM+1
       BRA READS
*
* READ SECTORS FROM CF
*
READ   LDX #SECPMT
       JSR PSTRNG
       JSR IN6HEX
       BVS RDEXIT
       STB SECNUM
       STX SECNUM+1
*
READS  CLRA
       LDB #$01
       STD CF_SECCNT
*
       LDB SECNUM+2
       STD CF_SECNUM
*
       LDB SECNUM+1
       STD CF_CYLLO
*
       LDB SECNUM+0
       STD CF_CYLHI
*
       LDB #CMDREAD ; IDE READ MULTIPLE
       STD CF_COMAND
       JSR WAITRDY
*
       LDX #SECBUF
       LDY #256
*
* READ LOOP
*
RDLOOP JSR WAITDRQ
       LDD CF_DATA ; reverse order of bytes
       STB ,X+
       STA ,X+
       LEAY -1,Y
       BNE RDLOOP
*
       JSR WAITRDY
       JSR MEMDUMP
RDEXIT JMP CMDLP
*
* WRITE SECTOR TO CF
*
WRITE  LDX #SECPMT
       JSR PSTRNG
       JSR IN6HEX
       BVS WREXIT
       STB SECNUM
       STX SECNUM+1
*
       CLRA
       LDB #$01
       STD CF_SECCNT
*
       LDB SECNUM+2
       STD CF_SECNUM
*
       LDB SECNUM+1
       STD CF_CYLLO
*
       LDB SECNUM+0
       STD CF_CYLHI
*
       LDD #CMDWRITE; IDE WRITE MULTIPLE
       STD CF_COMAND
       JSR WAITRDY
*
       LDX #SECBUF
       LDY #256
*
* WRITE LOOP
*
WRLOOP JSR WAITDRQ
       LDB ,X+    ; reverse order of bytes
       LDA ,X+
       STD CF_DATA
       LEAY -1,Y
       BNE WRLOOP
*
       JSR WAITRDY
WREXIT JMP CMDLP
*
* WAIT UNTIL READY
*
WAITRDY LDD CF_STATUS
        BITB #BUSY
        BNE WAITRDY
        LDD CF_STATUS
        BITB #DRDY
        BEQ WAITRDY
        RTS
*
* WAIT FOR DATA REQUEST
*
WAITDRQ LDD CF_STATUS
        BITB #DRQ
        BEQ WAITDRQ
        RTS
*
* DUMP SECTOR IN MEMORY
* 
MEMDUMP LDX  #SECMSG
        JSR  PSTRNG
        LDA  SECNUM
        JSR  OUT2H
        LDX  SECNUM+1
        JSR  OUT4H
        JSR  PCRLF
*
* Dump first 256 bytes
*
        LDY  #$0000
        LEAX #$0FF,Y
        JSR  AJDUMP
*
* Prompt to continue
*
        LDX #PAGMSG
        JSR PSTRNG
        JSR INCH
*
* Dump second 256 bytes
*
        LDY  #$0100
        LEAX #$0FF,Y
* 
* ADJUST LOWER AND UPPER ADDRESS LIMITS 
* TO EVEN 16 BYTE BOUNDRIES. 
* 
* IF LOWER ADDR = $4532 
* LOWER BOUNDS WILL BE ADJUSTED TO = $4530. 
* 
* IF UPPER ADDR = $4567 
* UPPER BOUNDS WILL BE ADJUSTED TO = $4570. 
* 
* ENTER WITH LOWER ADDRESS IN X-REG. 
*           -UPPER ADDRESS ON TOP OF STACK. 
* 
AJDUMP  TFR  X,D     GET UPPER ADDR IN D-REG 
        ADDD #$10    ADD 16 TO UPPER ADDRESS 
        ANDB #$F0    MASK TO EVEN 16 BYTE BOUNDRY 
        PSHS A,B     SAVE ON STACK AS UPPER DUMP LIMIT 
        TFR  Y,D     $F9A5 GET LOWER ADDRESS IN D-REG 
        ANDB #$F0    MASK TO EVEN 16 BYTE BOUNDRY 
        TFR  D,X     PUT IN X-REG AS LOWER DUMP LIMIT 
NXTLIN  CMPX ,S      COMPARE LOWER TO UPPER LIMIT 
        BEQ  SKPDMP  IF EQUAL SKIP HEX-ASCII DUMP 
        LBSR INCHEK  CHECK FOR INPUT FROM KEYBOARD 
        BEQ  EDUMP
SKPDMP  LEAS 2,S     READJUST STACK IF NOT DUMPING 
        RTS          ;
* 
* PRINT 16 HEX BYTES FOLLOWED BY 16 ASCII CHARACTERS 
* FOR EACH LINE THROUGHOUT ADDRESS LIMITS. 
* 
EDUMP   PSHS X       PUSH LOWER ADDR LIMIT ON STACK 
        LDX  #MSG5   POINT TO MSG " - " 
        LBSR PSTRNG  PRINT MSG 
        LDX  ,S      LOAD LOWER ADDR FROM TOP OF STACK 
        LBSR OUT4H   PRINT THE ADDRESS
        LBSR OUT2S   2 SPACES 
        LDB  #$10    LOAD COUNT OF 16 BYTES TO DUMP 
ELOOP   LDA  SECBUF,X     GET FROM MEMORY HEX BYTE TO PRINT 
        LEAX 1,X
        LBSR OUT2H   OUTPUT HEX BYTE AS ASCII 
        LBSR OUT1S   OUTPUT SPACE 
        DECB         $F9D1 DECREMENT BYTE COUNT 
        BNE  ELOOP   CONTINUE TIL 16 HEX BYTES PRINTED 
* 
* PRINT 16 ASCII CHARACTERS 
* IF NOT PRINTABLE OR NOT VALID 
* ASCII PRINT A PERIOD (.) 
        LBSR OUT2S   2 SPACES 
        LDX  ,S++    GET LOW LIMIT FRM STACK - ADJ STACK 
        LDB  #$10    SET ASCII CHAR TO PRINT = 16 
EDPASC  LDA  SECBUF,X     GET CHARACTER FROM MEMORY 
        LEAX 1,X
        CMPA #$20    IF LESS THAN $20, NON-PRINTABLE? 
        BCS  PERIOD  IF SO, PRINT PERIOD INSTEAD 
        CMPA #$7E    IS IT VALID ASCII? 
        BLS  PRASC   IF SO PRINT IT 
PERIOD  LDA  #'.     LOAD A PERIOD (.) 
PRASC   LBSR OUTCH   PRINT ASCII CHARACTER 
        DECB         DECREMENT COUNT 
        BNE  EDPASC 
        BRA  NXTLIN 
*
* 
***** "M" MEMORY EXAMINE AND CHANGE ***** 
*
* RESTRICT ADDRESSING RANGE TO 512 BYTES ($000 - $1FF)
* 
MEMCHG  LDX  #MEMMSG
        JSR  PSTRNG
        LBSR IN3HEX  INPUT ADDRESS 
        BVS  CHRTN   IF NOT HEX, RETURN 
        CMPX #$0200
        BHS  CHRTN
        TFR  X,Y     SAVE ADDR IN "Y" 
MEMC2   LDX  #MSG5   POINT TO MSG " - " 
        LBSR PSTRNG  PRINT MSG 
        TFR  Y,X     FETCH ADDRESS 
        LBSR OUT4H   PRINT ADDR IN HEX 
        LBSR OUT1S   OUTPUT SPACE 
        LDA  SECBUF,Y GET CONTENTS OF CURRENT ADDR. 
        LBSR OUT2H   OUTPUT CONTENTS IN ASCII 
        LBSR OUT1S   OUTPUT SPACE 
        LBSR BYTE    LOOP WAITING FOR OPERATOR INPUT 
        BVC  CHANGE  IF VALID HEX GO CHANGE MEM. LOC. 
        CMPA #8      IS IT A BACKSPACE (CNTRL H)? 
        BEQ  MEMC2   PROMPT OPERATOR AGAIN 
        CMPA #$18    IS IT A CANCEL (CNTRL X)? 
        BEQ  MEMC2   PROMPT OPERATOR AGAIN 
        CMPA #'^     IS IT AN UP ARROW? 
        BEQ  BACK    DISPLAY PREVIOUS BYTE 
        CMPA #$D     IS IT A CR? 
        BNE  FORWRD  DISPLAY NEXT BYTE 
CHRTN   RTS          EXIT ROUTINE 
* 
* 
CHANGE  STA  SECBUF,Y      CHANGE BYTE IN MEMORY 
        CMPA SECBUF,Y      DID MEMORY BYTE CHANGE? 
        BEQ  FORWRD  $F972 
        LBSR OUT1S   OUTPUT SPACE 
        LDA  #'?     LOAD QUESTION MARK 
        LBSR OUTCH   PRINT IT 
FORWRD  CMPY #$01FF
        BEQ  MEMC2
        LEAY 1,Y     POINT TO NEXT HIGHER MEM LOCATION 
        BRA  MEMC2   PRINT LOCATION & CONTENTS 
BACK    CMPY #$0000
        BEQ  MEMC2
        LEAY -1,Y    POINT TO LAST MEM LOCATION 
        BRA  MEMC2   PRINT LOCATION & CONTENTS 
* 
* THE FOLLOWING ROUTINE LOOPS WAITING FOR THE 
* OPERATOR TO INPUT ONE VALID HEX ADDRESS. THE 
* ADDRESS IS RETURNED IN THE "X" REGISTER. 
* 
* IN6HEX - MS BYTE IN ACCB
*          LS WORD IN X REG
*
IN6HEX LEAS -3,S
       BSR  BYTE
       BVS  NOTHEX
       STA  0,S
       BSR  BYTE
       BVS  NOTHEX
       STA  1,S
       BSR  BYTE
       BVS  NOTHEX
       STA  2,S
       CLRA
       PULS B,X,PC
*
* INPUT 3 HEX DIGITS
* RESULT RETURNED IN X
*
IN3HEX BSR INHEX INPUT HEX (1 HEX CHAR) 
       BVS NOTHEX EXIT IF NOT VALID HEX 
       TFR  D,X 
       BSR BYTE INPUT BYTE (2 HEX CHAR) 
       BVS NOTHEX 
       PSHS X 
       STA  1,S 
       PULS X,PC 
* 
***** INPUT BYTE (2 HEX CHAR.) ***** 
* 
BYTE   BSR INHEX GET HEX LEFT 
       BVS NOTHEX EXIT IF NOT VALID HEX 
       ASLA   ;
       ASLA   ;
       ASLA   ; SHIFT INTO LEFT NIBBLE
       ASLA   ;
       TFR  A,B PUT HEXL IN "B" 
       BSR INHEX GET HEX RIGHT 
       BVS NOTHEX EXIT IF NOT VALID HEX 
       PSHS B PUSH HEXL ON STACK 
       ADDA ,S+ ADD HEXL TO HEXR AND ADJ. STK 
       RTS  RETURN WITH HEX L&R IN "A" 
* 
* 
INHEX  BSR ECHON INPUT ASCII CHAR. 
       CMPA #'0 IS IT > OR = "0" ? 
       BCS NOTHEX IF LESS IT AIN'T HEX 
       CMPA #'9 IS IT < OR = "9" ? 
       BHI INHEXA IF > MAYBE IT'S ALPHA 
       SUBA #$30 ASCII ADJ. NUMERIC 
       RTS  ;
* 
* 
INHEXA CMPA #'A IS IT > OR = "A" 
       BCS NOTHEX IF LESS IT AIN'T HEX 
       CMPA #'F IS IT < OR = "F" ? 
       BHI INHEXL IF > IT AIN'T HEX 
       SUBA #$37 ASCII ADJ. ALPHA 
       RTS  ;
* 
INHEXL CMPA #'a IS IT > OR = "a" 
       BCS NOTHEX IF LESS IT AIN'T HEX 
       CMPA #'f IS IT < "f" 
       BHI NOTHEX IF > IT AIN'T HEX 
       SUBA #$57 ADJUST TO LOWER CASE 
       RTS  ;
* 
* 
NOTHEX ORCC #2 SET (V) FLAG IN C-CODES REGISTER 
       RTS  ;
* 
* 
OUT4H PSHS X PUSH X-REG. ON THE STACK 
       PULS A POP MS BYTE OF X-REG INTO A-ACC. 
       BSR OUTHL OUTPUT HEX LEFT 
       PULS A POP LS BYTE OF X-REG INTO A-ACC. 
OUTHL EQU * 
OUT2H PSHS A SAVE IT BACK ON STACK 
       LSRA CONVERT UPPER HEX NIBBLE TO ASCII 
       LSRA  ;
       LSRA  ;
       LSRA  ;
       BSR XASCII PRINT HEX NIBBLE AS ASCII 
OUTHR PULS A CONVERT LOWER HEX NIBBLE TO ASCII 
       ANDA #$0F STRIP LEFT NIBBLE 
XASCII ADDA #$30 ASCII ADJ 
       CMPA #$39 IS IT < OR = "9" ? 
       BLE  OUTC IF LESS, OUTPUT IT 
       ADDA #7 IF > MAKE ASCII LETTER 
OUTC BRA  OUTCH OUTPUT CHAR 
* 
* BINARY / ASCII --- THIS ROUTINE 
* OUTPUTS A BYTE IN ENHANCED 
* BINARY FORMAT. THE ENHANCEMENT 
* IS DONE BY SUBSTITUTING ASCII 
* LETTERS FOR THE ONES IN THE BYTE. 
* THE ASCII ENHANCEMENT LETTERS 
* ARE OBTAINED FROM THE STRING 
* POINTED TO BY THE INDEX REG. "X". 
* 
BIASCI PSHS A SAVE "A" ON STACK 
       LDB  #8 PRESET LOOP# TO BITS PER BYTE 
OUTBA LDA ,X+ GET LETTER FROM STRING 
       ASL  ,S TEST BYTE FOR "1" IN B7 
       BCS PRTBA IF ONE PRINT LETTER 
       LDA #'- IF ZERO PRINT "-" 
PRTBA BSR OUTCH PRINT IT 
       BSR OUT1S PRINT SPACE 
       DECB SUB 1 FROM #BITS YET TO PRINT 
       BNE OUTBA 
       PULS A,PC
* 
* PRINT STRING PRECEEDED BY A CR & LF. 
* 
PSTRNG JMP [PSTRGV] PRINT CR/LF 
* 
* PCRLF 
* 
PCRLF  JMP [PCRLFV]
* 
* PDATA 
* 
PDATA  JMP [PDATAV]
* 
ECHON  TST  ECHO IS ECHO REQUIRED ? 
       BEQ  INCH ECHO NOT REQ. IF CLEAR 
* 
* INCHE 
* 
* ---GETS CHARACTER FROM TERMINAL AND 
* ECHOS SAME. THE CHARACTER IS RETURNED 
* IN THE "A" ACCUMULATOR WITH THE PARITY 
* BIT MASKED OFF. ALL OTHER REGISTERS 
* ARE PRESERVED. 
* 
INCHE  JMP [INCHEV]
* 
* INCH 
* 
* GET CHARACTER FROM TERMINAL. RETURN 
* CHARACTER IN "A" ACCUMULATOR AND PRESERVE 
* ALL OTHER REGISTERS. THE INPUT CHARACTER 
* IS 8 BITS AND IS NOT ECHOED. 
* 
* 
INCH    JMP [INCHV]
* 
* INCHEK 
* 
* CHECK FOR A CHARACTER AVAILABLE FROM 
* THE TERMINAL. THE SERIAL PORT IS CHECKED 
* FOR READ READY. ALL REGISTERS ARE 
* PRESERVED, AND THE "Z" BIT WILL BE 
* CLEAR IF A CHARACTER CAN BE READ. 
* 
* 
INCHEK  JMP [INCHEKV]
* 
OUT2S   BSR OUT1S OUTPUT 2 SPACES 
OUT1S   LDA  #$20  OUTPUT 1 SPACE 
* 
* 
* OUTCH 
* 
* OUTPUT CHARACTER TO TERMINAL. 
* THE CHAR. TO BE OUTPUT IS 
* PASSED IN THE A REGISTER. 
* ALL REGISTERS ARE PRESERVED. 
* 
OUTCH   JMP [OUTCHV]
*
* MESSAGE STRINGS
*
TTLMSG FCB $0A,$0D
       FCC "COMPACT FLASH SECTOR READ/WRITE UTILITY"
       FCB $04
CMDMSG FCB $0D,$0A
       FCC "(R) READ SECTOR   "
       FCC "(W) WRITE SECTOR  "
       FCB $0D,$0A
       FCC "(N) NEXT SECTOR   "
       FCC "(P) PREV SECTOR   "
       FCB $0D,$0A
       FCC "(M) MODIFY SECTOR "
       FCC "(Q) QUIT          "
       FCB $0D,$0A
       FCC ": "
       FCB $04
SECPMT FCC "SECTOR NUMBER (6 HEX) : "
       FCB $04
SECMSG FCC "SECTOR NUMBER - $"
       FCB $04
MEMMSG FCB $0D,$0A
       FCC "MEMORY ADDRESS (3 HEX): "
       FCB $04
MSG5   FCC " - "
       FCB $04
MSG2   FCB $00,$00,$0A,$0D,$00,$00,$00,$04
WOTMSG FCC "What ?"
       FCB $0D,$0A,$04
PAGMSG FCB $0D,$0A
       FCC "Hit any key to continue"
       FCB $04
*
       END START
