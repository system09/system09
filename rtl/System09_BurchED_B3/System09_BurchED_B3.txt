--===========================================================================----
--
--  System09 - Synthesizable System On a Chip - VHDL FPGA core top level file.
--
--===========================================================================----
--
--  This core adheres to the GNU public license  
--
-- Disclaimer:
-- ===========
-- "System09_BurchED_B3.vhd" may be freely distributed, provided that 
-- no charge above the cost of distribution is levied, and that this 
-- disclaimer is always attached to it. The VHDL FPGA core design is provided 
-- as is without any guarantees or warranty. Although the author has attempted 
-- to find and correct any bugs in this free VHDL FPGA core, the author 
-- is not responsible for any damage or losses of any kind caused by the 
-- use or misuse of this VHDL FPGA core. The author is under no obligation 
-- to provide support, service, corrections, or upgrades to this free FPGA 
-- VHDL core.
--
-- File name      : System09_BurchED_B3.vhd
--
-- Purpose        : This is the top level file for a 6809 instruction compatible system on a chip 
--                  It has been designed for the BurchED B3 Spartan2+ FPGA board
--                  using the Xilinx XC2S200 Spartan 2 FPGA and Xilinx ISE 7.1 software.
--                  It has been implemented with the BurchED B3 FPGA board, 
--                  modified B3-SRAM module and B3-FPGA-CPU-IO module. 
--                  It also supports an IDE CF card interface using a CF to IDE interface adapter.
--
-- Dependencies   : ieee.Std_Logic_1164
--                  ieee.std_logic_unsigned
--                  ieee.std_logic_arith
--                  ieee.numeric_std
--
-- Uses           : 
--                  cpu09         (cpu09.vhd)       CPU core
--                  sys09bug_F800 (sys09b3s_b4.vhd) Monitor ROM
--                  dat_ram       (datram.vhd)      SWTPc compatible Dynamic Address Translation (DAT)
--                  acia_6850     (ACIA_6850.vhd)   RS232 Serial Interface
--                                (ACIA_RX.vhd)     ACIA Receive Unit
--                                (ACIA_TX.vhd)     ACIA Transmit Unit
--                  ACIA_Clock    (ACIA_Clock.vhd)  ACIA Baud Rate Clock Divider
--                  keyboard      (keyboard.vhd)    PS/2 Keyboard Interface
--                  vdu8          (vdu8.vhd)        80 x 25 Visual Display Unit.
--                  timer         (timer.vhd)       Timer module
--                  trap	    (trap.vhd)        Bus Trap interrupt
--                  spp           (spp.vhd)         Simple Parallel Port.
-- 
-- Author         : John E. Kent      
--                  dilbert57@opencores.org
-- Memory Map     :
--
-- $E000 - ACIA (SWTPc)
-- $E010 - Reserved for SWTPc FD-01 FD1771 FDC
-- $E020 - Keyboard
-- $E030 - VDU
-- $E040 - Reserved for SWTPc MP-T (was Compact Flash)
-- $E050 - Timer
-- $E060 - Bus Trap (Hardware Breakpoint Interrupt Logic)
-- $E070 - Reserved for Trace Buffer
-- $E080 - Reserved for SWTPc MP-ID 6821 PIA (?)
-- $E090 - Reserved for SWTPc MP-ID 6840 PTM (?)
-- $E0A0 - Printer Port
-- $E0B0 - Reserved
-- $E0C0 - Reserved
--
--===========================================================================----
--
-- Revision History:
--===========================================================================--
-- Version 0.1 - 20 March 2003
-- Version 0.2 - 30 March 2003
-- Version 0.3 - 29 April 2003
-- Version 0.4 - 29 June 2003
--
-- Version 0.5 - 19 July 2003
-- prints out "Hello World"
--
-- Version 0.6 - 5 September 2003
-- Runs SBUG
--
-- Version 1.0- 6 Sep 2003 - John Kent
-- Inverted SysClk
-- Initial release to Open Cores
--
-- Version 1.1 - 17 Jan 2004 - John Kent
-- Updated miniUart.
--
-- Version 1.2 - 25 Jan 2004 - John Kent
-- removed signals "test_alu" and "test_cc" 
-- Trap hardware re-instated.
--
-- Version 1.3 - 11 Feb 2004 - John Kent
-- Designed forked off to produce System09_VDU
-- Added VDU component
--	VDU runs at 25MHz and divides the clock by 2 for the CPU
-- UART Runs at 57.6 Kbps
--
-- Version 1.4 - 21 Nov 2004 - John Kent
-- Changes to make compatible with Spartan3 starter kit version
-- Designed to run with a 50MHz clock input.
-- the VDU divides 50 MHz to generate a 
-- 25 MHz VDU Pixel Clock and a 12.5 MHz CPU clock
-- Changed Monitor ROM signals to make it look like
-- a standard 2K memory block
-- Re-assigned I/O port assignments so it is possible to run KBUG9
--
-- Version 1.5 - 3rd February 2007 - John Kent
-- Changed VDU8 to use external clock divider
-- renamed miniUART to ACIA_6850
-- Memory decoding of ROM & IO now uses DAT
--
-- Version 1.6 - 7th Februaury 2007 - John Kent
-- Made ACIA Clock generator an external component
-- Added Generics to VDU and Keyboard
-- Changed decoding
--
-- Version 1.7 - 20th May 2007 - John Kent
-- Added 4 wait states to CF access
-- Removed DAT memory map control of ROM & IO
-- to allow for full use of RAM as a RAM disk.
-- Mapped in all 16 bits of the CF data bus.
--
-- Version 1.8 - 1st July 2007 - John Kent
-- Copied B5-X300 top level to B3 version.
--
-- Version 2.0 - 6th September 2008 - John Kent
-- added IDE interface for a CF card.
-- Used separate Clock DLL for generating clocks
--
-- Version 2.1 - 23rd Februaury 2008 - John Kent
-- Renamed Monitor ROM
--
--===========================================================================
--
library ieee;
   use ieee.std_logic_1164.all;
   use IEEE.STD_LOGIC_ARITH.ALL;
   use IEEE.STD_LOGIC_UNSIGNED.ALL;
   use ieee.numeric_std.all;
library unisim;
   use unisim.vcomponents.all;

entity System09 is
  port(
    clk_in      : in  Std_Logic;  -- System Clock input
    reset_n     : in  Std_logic;  -- Master Reset input (active low)
    LED         : out Std_logic;  -- Diagnostic LED Flasher

    -- B3-SRAM Memory Interface signals

    ram_csn     : out Std_Logic;
    ram_wrln    : out Std_Logic;
    ram_wrun    : out Std_Logic;
    ram_addr    : out Std_Logic_Vector(16 downto 0);
    ram_data    : inout Std_Logic_Vector(15 downto 0);

    -- End of B3-SRAM Memory Interface signals

    -- B3-FPGA-CPU-IO Module signals

    -- Asychronous Communications Interface Adapater signals (RS232 Serial Port) ($E00X)
    acia_rxd    : in  Std_Logic;
    acia_txd    : out Std_Logic;
    acia_rts_n  : out Std_Logic;
    acia_cts_n  : in  Std_Logic;

    -- PS/2 Keyboard Interface ($E02X)
    kb_clock    : inout Std_logic;
    kb_data     : inout Std_Logic;

	-- PS/2 Mouse interface
--	 mouse_clock : in  Std_Logic;
--	 mouse_data  : in  Std_Logic;

    -- Visual Display Unit output signals ($E03X)
    vga_vsync   : out Std_Logic;
    vga_hsync   : out Std_Logic;
    vga_blue    : out std_logic_vector(1 downto 0);
    vga_green   : out std_logic_vector(1 downto 0);
    vga_red     : out std_logic_vector(1 downto 0);

    -- Buzzer
--	   buzzer      : out std_logic;

    -- End of B3-FPGA-CPU-IO Module signals

    -- Parallel Printer Port    ($E0AX)
    pp_data      : out std_logic_vector(7 downto 0);
    pp_stat      : in  std_logic_vector(7 downto 3);
    pp_ctrl      : out std_logic_vector(3 downto 0);

    -- Peripheral Bus ($E100 - $E1FF) 
    -- (for compatibility with XSA-3S1000 / XST 3.0)
    pb_iord_n    : out std_logic; -- ide pin 25
    pb_iowr_n    : out std_logic; -- ide pin 23
    pb_addr      : out std_logic_vector(2 downto 0);
    pb_data      : inout std_logic_vector(15 downto 0);

    -- IDE Compact Flash ($E100 - $E13F)
    ide_reset_n  : out std_logic; -- ide pin 1
    ide_cs0_n    : out std_logic; -- ide pin 37
    ide_cs1_n    : out std_logic; -- ide pin 38
    ide_dmarq    : in  std_logic; -- ide pin 21
    ide_dmack_n  : out std_logic; -- ide pin 29
    ide_iordy    : in  std_logic; -- ide pin 27
    ide_con_csel : out std_logic; -- ide pin 28
    ide_intrq    : in  std_logic; -- ide pin 31
    ide_iocs16_n : in  std_logic; -- ide pin 32
    ide_pdiag_n  : in  std_logic; -- ide pin 34
    ide_dasp_n   : out std_logic; -- ide pin 39

-- Dual port RAM interface bus
    bus_clk      : in  std_logic;
    bus_cs_n     : in  std_logic;
    bus_rw       : in  std_logic;
    bus_addr     : in  std_logic_vector(12 downto 0);
    bus_data_in  : in  std_logic_vector(7 downto 0);
    bus_data_out : out std_logic_vector(7 downto 0)
 );
end System09;

-------------------------------------------------------------------------------
-- Architecture for System09
-------------------------------------------------------------------------------
architecture rtl of System09 is
  -----------------------------------------------------------------------------
  -- constants
  -----------------------------------------------------------------------------
  constant SYS_CLK_FREQ  : integer := 50000000;  -- FPGA System Clock
  constant VGA_CLK_FREQ  : integer := 25000000;  -- VGA Pixel Clock
  constant CPU_CLK_FREQ  : integer := 12500000;  -- CPU Clock
  constant BAUD_RATE     : integer := 57600;	  -- Baud Rate
  constant ACIA_CLK_FREQ : integer := BAUD_RATE * 16;

  type hold_state_type is ( hold_release_state, hold_request_state );

  -----------------------------------------------------------------------------
  -- Signals
  -----------------------------------------------------------------------------

  -- System Clock
  signal sys_clk      : std_logic;

  -- CPU Interface signals
  signal cpu_reset    : Std_Logic;
  signal cpu_clk      : Std_Logic;
  signal cpu_rw       : std_logic;
  signal cpu_vma      : std_logic;
  signal cpu_halt     : std_logic;
  signal cpu_hold     : std_logic;
  signal cpu_firq     : std_logic;
  signal cpu_irq      : std_logic;
  signal cpu_nmi      : std_logic;
  signal cpu_addr     : std_logic_vector(15 downto 0);
  signal cpu_data_in  : std_logic_vector(7 downto 0);
  signal cpu_data_out : std_logic_vector(7 downto 0);
  signal cpu_wr       : std_logic;

  -- Dynamic Address Translation	($FFF0 - $FFFF)
  signal dat_cs       : std_logic;
  signal dat_addr     : std_logic_vector(7 downto 0);

  -- Monitor ROM              ($F800 - $FFFF)
  signal rom_data_out  : Std_Logic_Vector(7 downto 0);
  signal rom_cs        : std_logic;

  -- ACIA Console serial port ($E000 - $E00F)
  signal acia_data_out : Std_Logic_Vector(7 downto 0);  
  signal acia_cs       : Std_Logic;
  signal acia_irq      : Std_Logic;
  signal acia_clk      : Std_Logic;

  -- PS/2 Keyboard interface  ($E02X)
  signal key_data_out  : std_logic_vector(7 downto 0);
  signal key_cs        : std_logic;
  signal key_irq       : std_logic;

  -- Visual Display Unit      ($E03X)
  signal vga_clk       : std_logic;
  signal vdu_cs        : std_logic;
  signal vdu_data_out  : std_logic_vector(7 downto 0);
  signal vga_red_o     : std_logic;
  signal vga_green_o   : std_logic;
  signal vga_blue_o    : std_logic;

  -- Timer                    ($E05X)
  signal timer_data_out : std_logic_vector(7 downto 0);
  signal timer_cs    : std_logic;
  signal timer_irq   : std_logic;

  -- Bus trap                 ($E06X)
  signal trap_cs         : std_logic;
  signal trap_data_out   : std_logic_vector(7 downto 0);
  signal trap_irq        : std_logic;

  -- Trace                    ($E07X)
  signal trace_cs          : std_logic;
  signal trace_data_out    : std_logic_vector(7 downto 0);
--  signal trace_irq         : std_logic;

  -- Simple Parallel I/O port ($E0AX)
  signal spp_data_out   : std_logic_vector(7 downto 0);
  signal spp_cs         : std_logic;

  -- IDE CF port              ($E100 - $E13F)
  signal pb_data_out   : std_logic_vector(7 downto 0);
  signal pb_cs         : std_logic;	  -- ide drive chip select
  signal pb_wru        : std_logic;	  -- upper byte write strobe
  signal pb_wrl        : std_logic;	  -- lower byte write strobe
  signal pb_rdu        : std_logic;	  -- upper byte read strobe
  signal pb_rdl        : std_logic;	  -- lower byte read strobe
  signal pb_hold       : std_logic;	  -- hold peripheral bus access
  signal pb_release    : std_logic;	  -- release hold of peripheral bus
  signal pb_count      : std_logic_vector(3 downto 0); -- hold counter
  signal pb_hold_state : hold_state_type;
  signal pb_wreg       : std_logic_vector(7 downto 0); -- lower byte write register
  signal pb_rreg       : std_logic_vector(7 downto 0); -- lower byte read register

  -- Peripheral chip selects on Peripheral Bus (XSA-3S1000 / XST-3.0)
  -- IDE / CF interface        ($E100 - $E13F)
  signal ide_cs        : std_logic;	
  -- Ethernet interface        ($E140 - $E17F)
  signal ether_cs      : std_logic;	
  -- Expansion slot1 interface ($E180 - $E1BF)
  signal slot1_cs      : std_logic;	-- Expansion slot 1
  -- Expansion slot2 interface ($E1C0 - $E1FF)
  signal slot2_cs      : std_logic;	-- Expansion slot 2

  -- Dual Port RAM for Bus Interfacing	($E200 - $E7FF)
  signal dpr_data_out   : std_logic_vector(7 downto 0);
  signal dpr_cs         : std_logic;

  -- External Bus Interface
  signal bus_iclk     : std_logic;
  signal bus_gclk     : std_logic;
  signal bus_cs       : std_logic;
  signal bus_wr       : std_logic;

  -- Flex ROMs (not available on BurchED Spartan2 boards)
  signal flex_cs       : std_logic;
--  signal flex_data_out : std_logic;

  -- Static RAM ($0000 - $DFFF)
  signal ram_cs      : std_logic; -- memory chip select
  signal ram_we      : std_logic; -- memory write strobe
  signal ram_wrl     : std_logic; -- memory write lower
  signal ram_wru     : std_logic; -- memory write upper
  signal ram_data_out    : std_logic_vector(7 downto 0);

  -- Flashing LED test signals
  signal countL       : std_logic_vector(23 downto 0);

-----------------------------------------------------------------
--
-- Clock generator
--
-----------------------------------------------------------------

component clock_div
  port(
    clk_in      : in  std_Logic;  -- System Clock input
	 sys_clk     : out std_logic;  -- System Clock Out    (1/1)
	 vga_clk     : out std_logic;  -- VGA Pixel Clock Out (1/2)
    cpu_clk     : out std_logic  -- CPU Clock Out       (1/4)
  );
end component;

-----------------------------------------------------------------
--
-- CPU core
--
-----------------------------------------------------------------

component cpu09
  port (    
    clk:      in	std_logic;
    rst:      in	std_logic;
    rw:       out	std_logic;		-- Asynchronous memory interface
    vma:      out	std_logic;
    address:  out	std_logic_vector(15 downto 0);
    data_in:  in	std_logic_vector(7 downto 0);
    data_out: out std_logic_vector(7 downto 0);
    halt:     in  std_logic;
    hold:     in  std_logic;
    irq:      in  std_logic;
    nmi:      in  std_logic;
    firq:     in  std_logic
  );
end component;


----------------------------------------
--
-- Sys09Bug Block RAM Monitor ROM
--
----------------------------------------
component sys09bug_F800
    port (
       clk   : in  std_logic;
       rst   : in  std_logic;
       cs    : in  std_logic;
       rw    : in  std_logic;
       addr  : in  std_logic_vector (10 downto 0);
       wdata : in  std_logic_vector (7 downto 0);
       rdata : out std_logic_vector (7 downto 0)
    );
end component;


-----------------------------------------------------------------
--
-- Dynamic Address Translation Registers ($FFF0 - $FFFF)
--
-----------------------------------------------------------------
component dat_ram
  port (
    clk      : in  std_logic;
    rst      : in  std_logic;
    cs       : in  std_logic;
    rw       : in  std_logic;
    addr_lo  : in  std_logic_vector(3 downto 0);
    addr_hi  : in  std_logic_vector(3 downto 0);
    data_in  : in  std_logic_vector(7 downto 0);
    data_out : out std_logic_vector(7 downto 0)
  );
end component;

-----------------------------------------------------------------
--
-- 6850 ACIA RS232 Interface  ($E000 - $E00F)
--
-----------------------------------------------------------------

component ACIA_6850
  port (
     clk      : in  Std_Logic;  -- System Clock
     rst      : in  Std_Logic;  -- Reset input (active high)
     cs       : in  Std_Logic;  -- miniUART Chip Select
     rw       : in  Std_Logic;  -- Read / Not Write
     irq      : out Std_Logic;  -- Interrupt
     Addr     : in  Std_Logic;  -- Register Select
     DataIn   : in  Std_Logic_Vector(7 downto 0); -- Data Bus In 
     DataOut  : out Std_Logic_Vector(7 downto 0); -- Data Bus Out
     RxC      : in  Std_Logic;  -- Receive Baud Clock
     TxC      : in  Std_Logic;  -- Transmit Baud Clock
     RxD      : in  Std_Logic;  -- Receive Data
     TxD      : out Std_Logic;  -- Transmit Data
     DCD_n    : in  Std_Logic;  -- Data Carrier Detect
     CTS_n    : in  Std_Logic;  -- Clear To Send
     RTS_n    : out Std_Logic );  -- Request To send
end component;

-----------------------------------------------------------------
--
-- ACIA Clock divider
--
-----------------------------------------------------------------

component ACIA_Clock
  generic (
     SYS_CLK_FREQ  : integer := SYS_CLK_FREQ;
     ACIA_CLK_FREQ : integer := ACIA_CLK_FREQ
  );   
  port (
     clk      : in  Std_Logic;  -- System Clock Input
     ACIA_clk : out Std_logic   -- ACIA Clock output
  );
end component;

----------------------------------------
--
-- PS/2 Keyboard ($E020 - $E02F)
--
----------------------------------------

component keyboard
  generic(
     KBD_CLK_FREQ : integer := CPU_CLK_FREQ
  );
  port (
     clk         : in    std_logic;
     rst         : in    std_logic;
     cs          : in    std_logic;
     rw          : in    std_logic;
     addr        : in    std_logic;
     data_in     : in    std_logic_vector(7 downto 0);
     data_out    : out   std_logic_vector(7 downto 0);
     irq         : out   std_logic;
     kbd_clk     : inout std_logic;
     kbd_data    : inout std_logic
  );
end component;

----------------------------------------
--
-- Video Display Unit. ($E030 - $E03F)
--
----------------------------------------
component vdu8_mono
      generic(
        VDU_CLK_FREQ           : integer := CPU_CLK_FREQ; -- HZ
        VGA_CLK_FREQ           : integer := VGA_CLK_FREQ; -- HZ
        VGA_HOR_CHARS          : integer := 80; -- CHARACTERS
        VGA_VER_CHARS          : integer := 25; -- CHARACTERS
        VGA_PIX_PER_CHAR       : integer := 8;  -- PIXELS
        VGA_LIN_PER_CHAR       : integer := 16; -- LINES
        VGA_HOR_BACK_PORCH     : integer := 40; -- PIXELS
        VGA_HOR_SYNC           : integer := 96; -- PIXELS
        VGA_HOR_FRONT_PORCH    : integer := 24; -- PIXELS
        VGA_VER_BACK_PORCH     : integer := 13; -- LINES
        VGA_VER_SYNC           : integer := 1;  -- LINES
        VGA_VER_FRONT_PORCH    : integer := 36  -- LINES
      );
      port(
		-- control register interface
      vdu_clk      : in  std_logic;	 -- CPU Clock - 12.5MHz
      vdu_rst      : in  std_logic;
      vdu_cs       : in  std_logic;
      vdu_rw       : in  std_logic;
      vdu_addr     : in  std_logic_vector(2 downto 0);
      vdu_data_in  : in  std_logic_vector(7 downto 0);
      vdu_data_out : out std_logic_vector(7 downto 0);

      -- vga port connections
      vga_clk      : in  std_logic;	-- VGA Pixel Clock - 25 MHz
      vga_red_o    : out std_logic;
      vga_green_o  : out std_logic;
      vga_blue_o   : out std_logic;
      vga_hsync_o  : out std_logic;
      vga_vsync_o  : out std_logic
   );
end component;

----------------------------------------
--
-- Timer module  ($E050 - $E05F)
--
----------------------------------------

component timer
  port (
     clk       : in std_logic;
     rst       : in std_logic;
     cs        : in std_logic;
     rw        : in std_logic;
     addr      : in std_logic;
     data_in   : in std_logic_vector(7 downto 0);
     data_out  : out std_logic_vector(7 downto 0);
     irq       : out std_logic
  );
end component;

------------------------------------------------------------
--
-- Bus Trap logic	 ($E060 - $E06F)
--
------------------------------------------------------------

component trap
   port (	
      clk        : in  std_logic;
      rst        : in  std_logic;
      cs         : in  std_logic;
      rw         : in  std_logic;
      vma        : in  std_logic;
      addr       : in  std_logic_vector(15 downto 0);
      data_in    : in  std_logic_vector(7 downto 0);
      data_out   : out std_logic_vector(7 downto 0);
      irq        : out std_logic
   );
end component;

------------------------------------------------------------
--
-- Bus Trace logic	($E070 - $E07F)
--
------------------------------------------------------------
--component trace is
--  port (	
--    clk           : in  std_logic;
--    rst           : in  std_logic;
--    rs            : in  std_logic;	  -- register select
--    bs            : in  std_logic;	  -- bank select
--    rw            : in  std_logic;
--    vma           : in  std_logic;
--    addr          : in  std_logic_vector(15 downto 0);
--    data_in       : in  std_logic_vector(7 downto 0);
--    reg_data_out  : out std_logic_vector(7 downto 0);
--    buff_data_out : out std_logic_vector(7 downto 0);
--    cpu_data_in   : in  std_logic_vector(7 downto 0);
--    irq           : out std_logic
--  );
--end component;

----------------------------------------
--
-- Simple Parallel Port	($E0A0 - $E0AF)
--
----------------------------------------
component spp
   port (	
      clk       : in  std_logic;
      rst       : in  std_logic;
      cs        : in  std_logic;
      rw        : in  std_logic;
      addr      : in  std_logic_vector(2 downto 0);
      data_in   : in  std_logic_vector(7 downto 0);
      data_out  : out std_logic_vector(7 downto 0);
      spp_data  : out std_logic_vector(7 downto 0);
      spp_stat  : in  std_logic_vector(7 downto 3);
      spp_ctrl  : out std_logic_vector(3 downto 0);
      hold      : out std_logic;
      irq       : out std_logic
   );
end component;


------------------------------------------------------------
--
-- External Bus interface Dual port RAM ($E200 - $EFFF)
--
------------------------------------------------------------

component RAMB4_S8_S8
port (
  RSTA:  IN  std_logic;
  CLKA:  IN  std_logic;
  ENA:   IN  std_logic;
  WEA:   IN  std_logic;
  ADDRA: IN  std_logic_vector(8 downto 0);
  DIA:   IN  std_logic_vector(7 downto 0);
  DOA:   OUT std_logic_vector(7 downto 0);
  RSTB:  IN  std_logic;
  CLKB:  IN  std_logic;
  ENB:   IN  std_logic;
  WEB:   IN  std_logic;
  ADDRB: IN  std_logic_vector(8 downto 0);
  DIB:   IN  std_logic_vector(7 downto 0);
  DOB:   OUT std_logic_vector(7 downto 0)
  );
end component;

component IBUF
port (
  I : IN  std_logic;
  O : OUT std_logic
  );
end component;

component BUFG
port (
  I : IN  std_logic;
  O : OUT std_logic
  );
end component;

begin
  -----------------------------------------------------------------------------
  -- Instantiation of internal components
  -----------------------------------------------------------------------------
----------------------------------------
--
-- Clock generator
--
----------------------------------------
my_clock_div: clock_div port map (
    clk_in      => clk_in,   -- Clock input
    sys_clk     => sys_clk,  -- System Clock Out    (1/1)
    vga_clk     => vga_clk,  -- VGA Pixel Clock Out (1/2)
    cpu_clk     => cpu_clk   -- CPU Clock Out       (1/4)
  );

----------------------------------------
--
-- CPU09 CPU Core
--
----------------------------------------
my_cpu : cpu09  port map (    
    clk       => cpu_clk,
    rst       => cpu_reset,
    rw        => cpu_rw,
    vma       => cpu_vma,
    address   => cpu_addr(15 downto 0),
    data_in   => cpu_data_in,
    data_out  => cpu_data_out,
    halt      => cpu_halt,
    hold      => cpu_hold,
    irq       => cpu_irq,
    nmi       => cpu_nmi,
    firq      => cpu_firq
  );

----------------------------------------
--
-- Dynamic Address Translation Registers
--
----------------------------------------
my_dat : dat_ram port map (
    clk        => cpu_clk,
    rst        => cpu_reset,
    cs         => dat_cs,
    rw         => cpu_rw,
    addr_hi    => cpu_addr(15 downto 12),
    addr_lo    => cpu_addr(3 downto 0),
    data_in    => cpu_data_out,
    data_out   => dat_addr(7 downto 0)
  );

----------------------------------------
--
-- SYS09BUG Monitor ROM
--
----------------------------------------
my_rom : SYS09BUG_F800 port map (
       clk   => cpu_clk,
       rst   => cpu_reset,
       cs    => rom_cs,
       rw    => '1',
       addr  => cpu_addr(10 downto 0),
       wdata => cpu_data_out,
       rdata => rom_data_out
    );

----------------------------------------
--
-- ACIA RS232 Serial interface
--
----------------------------------------
my_ACIA  : ACIA_6850 port map (
    clk	     => cpu_clk,
    rst       => cpu_reset,
    cs        => acia_cs,
    rw        => cpu_rw,
    irq       => acia_irq,
    addr      => cpu_addr(0),
    datain    => cpu_data_out,
    DataOut   => acia_data_out,
    RxC       => acia_clk,
    TxC       => acia_clk,
    RxD       => acia_rxd,
    TxD       => acia_txd,
    DCD_n     => '0',
    CTS_n     => acia_cts_n,
    RTS_n     => acia_rts_n
  );

----------------------------------------
--
-- ACIA Clock
--
----------------------------------------
my_ACIA_Clock : ACIA_Clock
  generic map(
    SYS_CLK_FREQ  => SYS_CLK_FREQ,
    ACIA_CLK_FREQ => ACIA_CLK_FREQ
  ) 
  port map(
    clk        => sys_clk,
    acia_clk   => acia_clk
  ); 

----------------------------------------
--
-- PS/2 Keyboard Interface
--
----------------------------------------
my_keyboard : keyboard
   generic map (
	KBD_CLK_FREQ => CPU_CLK_FREQ
   ) 
   port map(
	clk          => cpu_clk,
	rst          => cpu_reset,
	cs           => key_cs,
	rw           => cpu_rw,
	addr         => cpu_addr(0),
	data_in      => cpu_data_out(7 downto 0),
	data_out     => key_data_out(7 downto 0),
	irq          => key_irq,
	kbd_clk      => kb_clock,
	kbd_data     => kb_data
	);

----------------------------------------
--
-- Video Display Unit instantiation
--
----------------------------------------
my_vdu : vdu8_mono 
  generic map(
      VDU_CLK_FREQ           => CPU_CLK_FREQ, -- HZ
      VGA_CLK_FREQ           => VGA_CLK_FREQ, -- HZ
      VGA_HOR_CHARS          => 80, -- CHARACTERS
      VGA_VER_CHARS          => 25, -- CHARACTERS
      VGA_PIX_PER_CHAR       => 8,  -- PIXELS
      VGA_LIN_PER_CHAR       => 16, -- LINES
      VGA_HOR_BACK_PORCH     => 40, -- PIXELS
      VGA_HOR_SYNC           => 96, -- PIXELS
      VGA_HOR_FRONT_PORCH    => 24, -- PIXELS
      VGA_VER_BACK_PORCH     => 13, -- LINES
      VGA_VER_SYNC           => 1,  -- LINES
      VGA_VER_FRONT_PORCH    => 36  -- LINES
  )
  port map(

  -- Control Registers
      vdu_clk       => cpu_clk,					 -- 12.5 MHz System Clock in
      vdu_rst       => cpu_reset,
      vdu_cs        => vdu_cs,
      vdu_rw        => cpu_rw,
      vdu_addr      => cpu_addr(2 downto 0),
      vdu_data_in   => cpu_data_out,
      vdu_data_out  => vdu_data_out,

      -- vga port connections
      vga_clk       => vga_clk,					 -- 25 MHz VDU pixel clock
      vga_red_o     => vga_red_o,
      vga_green_o   => vga_green_o,
      vga_blue_o    => vga_blue_o,
      vga_hsync_o   => vga_hsync,
      vga_vsync_o   => vga_vsync
   );

----------------------------------------
--
-- Timer Module
--
----------------------------------------
my_timer  : timer port map (
    clk       => cpu_clk,
    rst       => cpu_reset,
    cs        => timer_cs,
    rw        => cpu_rw,
    addr      => cpu_addr(0),
    data_in   => cpu_data_out,
    data_out  => timer_data_out,
    irq       => timer_irq
    );

----------------------------------------
--
-- Bus Trap Interrupt logic
--
----------------------------------------
my_trap : trap port map (	
    clk        => cpu_clk,
    rst        => cpu_reset,
    cs         => trap_cs,
    rw         => cpu_rw,
    vma        => cpu_vma,
    addr       => cpu_addr,
    data_in    => cpu_data_out,
    data_out   => trap_data_out,
    irq        => trap_irq
    );

----------------------------------------
--
-- Bus Trace logic
--
----------------------------------------
--my_trace : trace port map (	
--    clk           => sys_clk,
--    rst           => cpu_reset,
--    rs            => trace_cs,
--    bs            => bank_cs,
--    rw            => cpu_rw,
--    vma           => cpu_vma,
--    addr          => cpu_addr,
--    data_in       => cpu_data_out,
--    reg_data_out  => trace_data_out,
--    buff_data_out => bank_data_out,
--    cpu_data_in   => cpu_data_in,
--    irq           => trace_irq
--    );


----------------------------------------
--
-- Simple Parallel Port
--
----------------------------------------
my_spp  : spp port map (
    clk       => cpu_clk,
    rst       => cpu_reset,
    cs        => spp_cs,
    rw        => cpu_rw,
    addr      => cpu_addr(2 downto 0),
    data_in   => cpu_data_out,
    data_out  => spp_data_out,
    spp_data  => pp_data,
    spp_stat  => pp_stat,
    spp_ctrl  => pp_ctrl,
    hold      => open,
    irq       => open
  );

----------------------------------------
--
-- External Bus interface Dual port RAM ($E200 - $EFFF)
--
----------------------------------------
my_dpr : RAMB4_S8_S8 port map (
  RSTA  => cpu_reset, 
  CLKA  => cpu_clk, 
  ENA   => dpr_cs, 
  WEA   => cpu_wr, 
  ADDRA => cpu_addr(8 downto 0), 
  DIA   => cpu_data_out, 
  DOA   => dpr_data_out,
  RSTB  => cpu_reset, 
  CLKB  => bus_gclk,
  ENB   => bus_cs,
  WEB   => bus_wr, 
  ADDRB => bus_addr(8 downto 0),
  DIB   => bus_data_in, 
  DOB   => bus_data_out 
  );

my_dpr_ibuf : IBUF port map (
  I     => bus_clk,
  O     => bus_iclk
  );

my_dpr_bufg : BUFG port map (
  I     => bus_iclk,
  O     => bus_gclk
  );
  	 
----------------------------------------------------------------------
--
-- Process to decode memory map
--
----------------------------------------------------------------------

mem_decode: process( cpu_addr, cpu_rw, cpu_vma,
                     dat_addr,
                     rom_data_out,
--                   flex_data_out,
                     acia_data_out,
                     key_data_out,
                     vdu_data_out,
                     pb_data_out,
                     timer_data_out,
                     trap_data_out,
                     trace_data_out,
                     spp_data_out,
                     dpr_data_out,
                     ram_data_out )
begin
   cpu_data_in <= (others=>'0');
   dat_cs      <= '0';
   rom_cs      <= '0';
   flex_cs     <= '0';
   acia_cs     <= '0';
   key_cs      <= '0';
   vdu_cs      <= '0';
   timer_cs    <= '0';
   trap_cs     <= '0';
   trace_cs    <= '0';
   spp_cs      <= '0';
   dpr_cs      <= '0';
   pb_cs       <= '0';
   ide_cs      <= '0';
   ether_cs    <= '0';
   slot1_cs    <= '0';
   slot2_cs    <= '0';
   ram_cs      <= '0';

   if cpu_addr( 15 downto 8 ) = "11111111" then
      --
      -- Dynamic Address Translation $FFF0 - $FFFF
      --
      cpu_data_in <= rom_data_out;
      dat_cs      <= cpu_vma;              -- write DAT
      rom_cs      <= cpu_vma;              -- read  ROM

   elsif (dat_addr(3 downto 0) = "1111") and (cpu_addr(11) = '1') then -- $XF800 - $XFFFF
      --
      -- Sys09Bug Monitor ROM $F000 - $FFFF
      --
      cpu_data_in <= rom_data_out;
      rom_cs      <= cpu_vma;

   elsif dat_addr(3 downto 0) = "1110" then -- $XE000 - $XEFFF
      --
      -- IO Devices $E000 - $E7FF
      --
      case cpu_addr(11 downto 8) is

      --
      -- SWTPC peripherals from $E000 to $E0FF
      --
      when "0000" =>
         case cpu_addr(7 downto 4) is
         --
         -- ACIA RS232 Console Port $E000 - $E00F
         --
         when "0000" => -- $E000
            cpu_data_in <= acia_data_out;
            acia_cs     <= cpu_vma;

         --
         -- Reserved
         -- Floppy Disk Controller port $E010 - $E01F
         --
         when "0001" => -- $E010
            null;

         --
         -- Keyboard port $E020 - $E02F
         --
         when "0010" => -- $E020
            cpu_data_in <= key_data_out;
            key_cs <= cpu_vma;

         --
         -- VDU port $E030 - $E03F
         --
         when "0011" => -- $E030
            cpu_data_in <= vdu_data_out;
            vdu_cs      <= cpu_vma;

         --
         -- Reserved SWTPc MP-T Timer $E040 - $E04F
         --
         when "0100" => -- $E040
            cpu_data_in <= (others=> '0');

         --
         -- Timer $E050 - $E05F
         --
         when "0101" => -- $E050
            cpu_data_in <= timer_data_out;
            timer_cs    <= cpu_vma;

         --
         -- Bus Trap Logic $E060 - $E06F
         --
         when "0110" => -- $E060
            cpu_data_in <= trap_data_out;
            trap_cs     <= cpu_vma;
 
         --
         -- Bus Trace Logic $E070 - $E07F
         --
         when "0111" => -- $E070
            cpu_data_in <= trace_data_out;
            trace_cs    <= cpu_vma;

         --
         -- Reserved SWTPc MP-ID PIA Timer/Printer Port $E080 - $E08F
         --
         when "1000" => -- $E080
            null;

         --
         -- Reserved SWTPc MP-ID PTM 6840 Timer Port $E090 - $E09F
         --

         --
         -- Simple Parallel Port $E0A0 - $E0AF
         --
         when "1010" => -- $E0A0
            cpu_data_in <= spp_data_out;
            spp_cs      <= cpu_vma;

         --
         -- Remaining 5 slots reserved for non SWTPc Peripherals
         --
         when others => -- $E0B0 to $E0FF
            cpu_data_in <= (others=> '0');

         end case;
      --
      -- XST-3.0 Peripheral Bus goes here
      -- $E100 to $E1FF
      -- Four devices
      -- IDE, Ethernet, Slot1, Slot2
      --
      when "0001" =>
         cpu_data_in <= pb_data_out;
         pb_cs       <= cpu_vma;

         case cpu_addr(7 downto 6) is
         --
         -- IDE Interface $E100 to $E13F
         --
         when "00" =>
            ide_cs   <= cpu_vma;

         --
         -- Ethernet Interface $E140 to $E17F
         --
         when "01" =>
            ether_cs <= cpu_vma;

         --
         -- Slot 1 Interface $E180 to $E1BF
         --
         when "10" =>
            slot1_cs <= cpu_vma;

         --
         -- Slot 2 Interface $E1C0 to $E1FF
         --
         when "11" =>
            slot2_cs <= cpu_vma;

         --
         -- Nothing else
         --
         when others =>
            null;

         end case;

      --
      -- $E200 to $EFFF reserved for future use
      --
      when others =>
         cpu_data_in <= dpr_data_out;
         dpr_cs      <= cpu_vma;

      end case;

   --
   -- Flex RAM $0C000 - $0DFFF
   --
-- elsif dat_addr(7 downto 1) = "0000110" then -- $0C000 - $0DFFF
--    cpu_data_in <= flex_data_out;
--    flex_cs     <= cpu_vma;

   --
   -- Everything else is RAM
   --
   else
      cpu_data_in <= ram_data_out;
      ram_cs      <= cpu_vma;
   end if;

end process;

--
-- 16-bit Peripheral Bus
-- 6809 Big endian
-- ISA bus little endian
-- Not sure about IDE interface
--
peripheral_bus: process( sys_clk, cpu_reset, cpu_rw, cpu_addr, cpu_data_out,
                         pb_cs, pb_wreg, pb_rreg )
begin
   pb_addr   <= cpu_addr(3 downto 1);
   --
   -- internal read/write strobes
   --
   pb_wru      <= pb_cs and (not cpu_rw) and (not cpu_addr(0));
   pb_wrl      <= pb_cs and (not cpu_rw) and      cpu_addr(0) ;
   pb_rdu      <= pb_cs and      cpu_rw  and (not cpu_addr(0));
   pb_rdl      <= pb_cs and      cpu_rw  and      cpu_addr(0) ;

   --
   -- Register upper byte from CPU on first CPU write
   -- and lower byte from the peripheral bus on first CPU read
   --
   if cpu_reset = '1' then
      pb_wreg <= (others => '0');
      pb_rreg <= (others => '0');
   elsif sys_clk'event and sys_clk ='1' then
      if pb_wru = '1' then
	   pb_wreg <= cpu_data_out;
      end if;
      if pb_rdu = '1' then
         pb_rreg <= pb_data(7 downto 0);
      end if;
   end if;
   --
   -- Peripheral bus read and write strobes are
   -- Syncronized with the 50 MHz clock
   -- and are asserted until the peripheral bus hold is released
   --
   if cpu_reset = '1' then
      pb_iowr_n <= '1';
      pb_iord_n <= '1';
   elsif sys_clk'event and sys_clk ='1' then
	if pb_hold = '1' then
         pb_iowr_n  <= not pb_wrl;
         pb_iord_n  <= not pb_rdu;
      else
         pb_iowr_n <= '1';
         pb_iord_n <= '1';
      end if;
   end if;
   --
   -- The peripheral bus will be an output 
   -- the registered even byte on data(15 downto 8)
   -- and the CPU odd bytes on data(7 downto 0)
   -- on odd byte writes
   --
   if pb_wrl = '1' then
      pb_data <= pb_wreg & cpu_data_out;
   else
     pb_data <= (others => 'Z');
   end if;

   --
   -- On even byte reads,
   -- the CPU reads the low (even) byte of the peripheral bus
   -- On odd byte reads,
   -- the CPU reads the registered (odd byte) input from the peripheral bus
   --
   if pb_rdu = '1' then
      pb_data_out <= pb_data(15 downto 8);
   elsif pb_rdl = '1' then
      pb_data_out <= pb_rreg;
   else
      pb_data_out <= (others => '0');
   end if;
  
end process;

--
-- Hold Peripheral bus accesses for a few cycles
--
peripheral_bus_hold: process( cpu_reset, cpu_clk, 
                              pb_cs, pb_hold_state, pb_release, pb_rdu, pb_wrl )
begin
    if cpu_reset = '1' then
		 pb_release    <= '0';
		 pb_count      <= "0000";
	    pb_hold_state <= hold_release_state;
	 elsif rising_edge(cpu_clk) then
  --
  -- The perpheral bus hold signal should be generated on 
  -- 16 bit bus read which will be on even byte reads or 
  -- 16 bit bus write which will be on odd byte writes.
  -- 
	    case pb_hold_state is
		 when hold_release_state =>
          pb_release <= '0';
		    if (pb_rdu = '1') or (pb_wrl = '1') then
			    pb_count      <= "0100";
				 pb_hold_state <= hold_request_state;
          elsif (pb_rdl = '1') or (pb_wru = '1') then
             pb_release    <= '1';
				 pb_hold_state <= hold_release_state;
			 end if;

		 when hold_request_state =>
			 if pb_count = "0000" then
--            if ether_rdy = '1' then
              pb_release    <= '1';
				  pb_hold_state <= hold_release_state;
--            end if;
          else
		       pb_count <= pb_count - "0001";
			 end if;
       when others =>
		    null;
       end case;
	 end if;
    pb_hold   <= pb_cs and (not pb_release);
end process;

--
-- IDE drive / CF card ($E100 - $E13F)
--
ide_bus: process( cpu_reset, cpu_addr, ide_cs )
begin
  --
  -- IDE Bus signals
  --
  ide_cs0_n    <= not( ide_cs ) or cpu_addr(4);
  ide_cs1_n    <= not( ide_cs and cpu_addr(4));
  ide_dmack_n  <= '1';
  ide_reset_n  <= not cpu_reset;
  ide_con_csel <= '0';
  ide_dasp_n   <= not ide_cs;

end process;

--
-- B3-SRAM Control
-- Processes to read and write memory based on bus signals
--
ram_process: process( cpu_reset, vga_clk,
                      cpu_addr, cpu_rw, cpu_vma, cpu_data_out,
					       dat_addr,
                      ram_cs, ram_we, ram_wrl, ram_wru, ram_data_out )
begin

    ram_csn  <=  not( ram_cs )    or  cpu_reset;
	 ram_addr(16 downto 11) <= dat_addr(5 downto 0);
	 ram_addr(10 downto 0)  <= cpu_addr(11 downto 1);
    --
    -- ram_hold signal helps 
    --
    if( cpu_reset = '1' ) then
	   ram_we   <= '0';
    --
	 -- Clock Hold on rising edge
	 --
    elsif falling_edge(vga_clk) then
	   if (ram_cs = '1') and (ram_we = '0') then
	     ram_we   <= not cpu_rw;
      else
	     ram_we   <= '0';
      end if;
    end if;

	 ram_wrl  <=      cpu_addr(0)  and ram_we;
    ram_wru  <= (not cpu_addr(0)) and ram_we;
	 ram_wrln <= not (ram_wrl);
	 ram_wrun <= not (ram_wru);

    if ram_wrl = '1' then
		ram_data(7 downto 0) <= cpu_data_out;
	 else
      ram_data(7 downto 0) <= "ZZZZZZZZ";
	 end if;

	 if ram_wru = '1' then
		ram_data(15 downto 8) <= cpu_data_out;
	 else
      ram_data(15 downto 8) <= "ZZZZZZZZ";
    end if;

	 if cpu_addr(0) = '0' then
      ram_data_out <= ram_data(15 downto 8);
	 else
      ram_data_out <= ram_data(7 downto 0);
    end if;
end process;

--
-- Interrupts and other bus control signals
--
cpu_controls : process( reset_n, cpu_rw,
                        acia_irq,
                        key_irq, 
                        trap_irq, 
                        timer_irq,
                        pb_hold
							 )
begin
   cpu_reset  <= not reset_n; -- CPU reset is active high
   cpu_irq    <= acia_irq or key_irq;
   cpu_nmi    <= trap_irq;
   cpu_firq   <= timer_irq;
   cpu_halt   <= '0';
   cpu_hold   <= pb_hold;
   cpu_wr     <= not cpu_rw;
end process;

--
-- bus interface signals
--
my_bus : process( bus_rw, bus_cs_n )
begin
   bus_cs <= not bus_cs_n;
   bus_wr <= not bus_rw;
   trace_data_out <= (others=>'0');
end process;

  --
  -- flash led to indicate code is working
  --
my_LED_Flasher: process (cpu_clk, CountL )
begin
   if(cpu_clk'event and cpu_clk = '0') then
      countL <= countL + 1;			 
   end if;
   LED <= countL(23);
end process;

--
-- Assign VDU VGA colour output
-- only 8 colours are handled.
--
my_vga_out: process( vga_red_o, vga_green_o, vga_blue_o )
begin
      vga_red(0)   <= vga_red_o;
      vga_red(1)   <= vga_red_o;
      vga_green(0) <= vga_green_o;
      vga_green(1) <= vga_green_o;
      vga_blue(0)  <= vga_blue_o;
      vga_blue(1)  <= vga_blue_o;
end process;

end rtl; --===================== End of architecture =======================--
